@import Main._
@import scalafix.Readme._

@sect{Part 2: Trees}
  @p
    Reminder. We assume you have this import in scope:

  @repl
    import scala.meta._

  @sect{.parse[T]}
    @p
      The first difference between tokens and trees is that trees are slightly
      tricker to obtain, you need to pass in a type argument!

    @p
      Here's how to parse a compilation unit.

    @meta
      "object Main extends App { println(1) }".parse[Source].get

    @p
      If we try to parse a statement as a compilation unit we will fail.

    @meta
      "val x = 2".parse[Source].get

    @p
      We need to explicitly parse it as a statement (@code{Stat}).

    @meta
      "val x = 2".parse[Stat].get

    @p
      We can also parse case statement

    @meta
      "case Foo(bar) if bar > 2 => println(bar)".parse[Case].get
    @p
      Scala.meta has dozens of parsers:
      @image("parse.png")
      However, @code{.parse[Stat]} and @code{.parse[Source]} are
      usually all you need.

  @sect{dialects}
    @p
      I didn't tell the whole story when I said you need to pass in a type
      argument to parse statements.
      You also need to pass in a dialect!
      However, scala.meta will by default pick the @code{Scala211} dialect
      for you if you don't provide one explicitly.

    @p
      With the SBT dialects, we can parse vals as top-level statements.

    @meta
      dialects.Sbt0137(
        "lazy val core = project.settings(commonSettings)"
      ).parse[Source].get

    @p
      We can even parse multiple top level statements

    @meta
      dialects.Sbt0137(
        """
        lazy val core = project.settings(commonSettings)

        lazy val extra = project.dependsOn(core)
        """
      ).parse[Source].get

    @p
      For the remainder of the workshop, we will only work with the @code{Scala211}
      dialect.

  @sect{.structure}
    @p
  @sect{.syntax}
    @p
