<!DOCTYPE html><html><head><link href="META-INF/resources/webjars/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" /><link href="styles.css" rel="stylesheet" /><link rel="shortcut icon" type="image/png" href="favicon.png" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style>
.scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.05;
  text-decoration: none;
}


.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.5;
  text-decoration: none;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:hover{
  opacity: 1.0;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:active{
  opacity: 0.75;
}

.scalatex-site-Styles-content{
  color: #777;
  line-height: 1.6em;
  margin: 0 auto;
  margin-left: auto;
  margin-right: auto;
  max-width: 800px;
  padding: 0 1em;
  padding-bottom: 50px;
}
.scalatex-site-Styles-content *{
  position: relative;
}
.scalatex-site-Styles-content p{
  text-align: justify;
}
.scalatex-site-Styles-content a:link{
  color: #37a;
  text-decoration: none;
}
.scalatex-site-Styles-content a:visited{
  color: #949;
  text-decoration: none;
}
.scalatex-site-Styles-content a:hover{
  text-decoration: underline;
}
.scalatex-site-Styles-content a:active{
  color: #000;
  text-decoration: underline;
}
.scalatex-site-Styles-content code{
  color: #000;
}

/*Workaround for bug in highlight.js IDEA theme*/
span.hljs-tag, span.hljs-symbol{
    background: none;
}
    </style><title>A Whirlwind Tour of scala.meta</title><script src="scripts.js"></script></head><body><div>


  <a href="https://github.com/olafurpg/scala.meta-workshop"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"></a>

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="AWhirlwindTourofscala.meta" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">A Whirlwind Tour of scala.meta<a class=" scalatex-site-Styles-headerLink" href="#AWhirlwindTourofscala.meta" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div><div class=" scalatex-site-Styles-content">
  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Abstract" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Abstract<a class=" scalatex-site-Styles-headerLink" href="#Abstract" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  <p>
    Metaprogramming enables us to do cool things such as build developer tools and implement macros that extend the functionality of a programming language.
    However, metaprogramming in Scala has historically been notoriously difficult because of its tight coupling with compiler internals.
</p>
  <p>
    This workshop is an introduction to
    <a href="http://scalameta.org">scala.meta</a>,
    a clean-room implementation of a metaprogramming toolkit for Scala,
    designed to be simple, robust and portable.
    We will focus on scala.meta's most unique features: high-fidelity tokens
    and comprehensive trees.
    You will get a hands-on experience with these features by using scala.meta in two different ways:

    <ol>
      <li>
        as a library to develop a tool that automatically fixes common linter errors.
        We will see how a code rewrite can be implemented in a few lines of code, tested on millions of lines of Scala code and be integrated with SBT and your favourite IDE.
</li>
      <li>
        as a compiler plugin to implement new-style &quot;inline&quot; macro annotations.
        We will see how inline style macros offer a much lower learning curve compared to scala.reflect macros.
</li></ol></p>
  <p>
    At the end of the workshop, I hope you will be inspired to develop the next generation of Scala tooling!
</p>
  <p>
    PS. I recommend IntelliJ users pre-install IntelliJ IDEA 2016.3 EAP for a sneak peek into new features to help you debug scala.meta based macros.</p>

  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Video" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Video<a class=" scalatex-site-Styles-headerLink" href="#Video" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  <p>
    Here's the video recording from this workshop at Scala World 2016.</p>
  
    <iframe width="100%" style="height: 28em" src="https://www.youtube.com/embed/-l7pV0sFq1c" frameborder="0" allowfullscreen></iframe>

  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Part0:Gettingstarted" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Part 0: Getting started<a class=" scalatex-site-Styles-headerLink" href="#Part0:Gettingstarted" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>

  <ol>
    <li>
      Clone the <a href="https://github.com/olafurpg/scala.meta-workshop">workshop repo</a>.
      Alternatively, for a minimal project template that uses the bleeding edge
      version of scalameta/paradise, clone
      <a href="https://github.com/olafurpg/scalameta-macro-template">this repo</a>.</li>
    <li>
      Run <code>sbt test</code> to make sure everything works.</li>
    <li>
      Setup the project in your favorite IDE, for example IntelliJ, ENSIME or vim.</li>
    <li>
      Open up <code>core/src/test/scala/scalaworld/Playground.scala</code>.</li>
    <li>
      Run <code>core/src/test/scala/scalaworld/Playground.scala</code>.
      Run <code>sbt &quot;~core/testOnly scalaworld.Playground&quot;</code>.
</li></ol>

  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Part1-Tokens" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Part 1 - Tokens<a class=" scalatex-site-Styles-headerLink" href="#Part1-Tokens" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  <p></p>
  <p>
    Make sure you have setup your environment from <a href="#Part0:Gettingstarted">Part 0: Getting started</a>.
    You can decide to run these examples from the console or from <code>Playground.scala</code>.
</p>
  <p>
    This whole workshop will assume you have this import in scope:
</p>
  <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; import scala.meta._
res0: scala.runtime.BoxedUnit = ()</code></pre>
  <p>
    Here's how to tokenize a small expression.

    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.tokenize.get
res0: scala.meta.tokens.Tokens = val x = 2</code></pre>
    Let's discuss the most interesting methods on tokens.

    <h1 id="Tokens.syntax" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tokens.syntax" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tokens.syntax</h1>
      <p>
        The simplest method we can call is <code>Tokens.syntax</code>
        The method returns a string representation of the actual code behind
        the tokens, or how the code should look like to a developer.
</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.tokenize.get.syntax
res0: java.lang.String = 
&quot;val x = 2&quot;</code></pre>
      <p>
        <code>Tokens.toString()</code> uses <code>.syntax</code> behind the scenes.
        However, you should never rely on <code>toString()</code> when manipulating
        scala.meta structures, prefer to explicitly call <code>.syntax</code>.
        It's maybe not so obvious why right now but it will make more sense soon.
</p>
    <h1 id="Tokens.structure" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tokens.structure" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tokens.structure</h1>
      <p>
        Another useful method is <code>Tokens.structure</code>.
        The method shows details that may be relevant to us as metaprogrammers.

        <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.tokenize.get.structure
res0: java.lang.String = 
&quot;Tokens(BOF [0..0), val [0..3),   [3..4), x [4..5),   [5..6), = [6..7),   [7..8), 2 [8..9), EOF [9..9))&quot;</code></pre></p>
      <p>
        <code>.structure</code> is often useful for debugging and testing.
</p>
    <h1 id="Tokensvs.Token" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tokensvs.Token" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tokens vs. Token</h1>
      <p>
        The class <code>Tokens</code> is a wrapper around a sequence of <code>Token</code> objects.
        There are multiple subtypes of <code>Token</code> while there only one type <code>Tokens</code>.

        <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.tokenize.get.head
res0: scala.meta.tokens.Token$BOF = </code></pre></p>
       <code>BOF</code> stands for &quot;Beginning of file&quot;.
       Let's see what other kinds of token types are in the string

        <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.tokenize.get
  .map(x =&gt; f&quot;${x.structure}%10s -&gt; ${x.getClass}&quot;)
  .mkString(&quot;\n&quot;)
res0: java.lang.String = 
&quot;BOF [0..0) -&gt; class scala.meta.tokens.Token$BOF
val [0..3) -&gt; class scala.meta.tokens.Token$KwVal
    [3..4) -&gt; class scala.meta.tokens.Token$Space
  x [4..5) -&gt; class scala.meta.tokens.Token$Ident
    [5..6) -&gt; class scala.meta.tokens.Token$Space
  = [6..7) -&gt; class scala.meta.tokens.Token$Equals
    [7..8) -&gt; class scala.meta.tokens.Token$Space
  2 [8..9) -&gt; class scala.meta.tokens.Token$Constant$Int
EOF [9..9) -&gt; class scala.meta.tokens.Token$EOF&quot;</code></pre>
        <p>
          Even spaces get their own tokens.
          The <code>[0...3)</code> part indicates that the <code>val</code> tokens start at
          offset 0 and ends at offset 3.
</p>
    <h1 id="==" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#==" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>==</h1>
      <p>
        How does token equality look like?
</p>
      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foobar&quot;.tokenize.get(1) == &quot;foobar kas&quot;.tokenize.get(1)
res0: java.lang.Boolean = false</code></pre>
      Huh, why are they not the same?

      <div class="bs-callout bs-callout-warning"><p>
        Token equality is implemented with reference equality.
        You need to be explicit if you actually mean syntactic (<code>.syntax</code>),
        or structural (<code>.structure</code>) equality.
</p></div>
      The tokens are syntactically equal.

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foobar&quot;.tokenize.get(1).syntax == &quot;foobar kas&quot;.tokenize.get(1).syntax
res0: java.lang.Boolean = true</code></pre>
      Even if we move the tokens around

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;kas foobar&quot;.tokenize.get(3).syntax == &quot;foobar kas&quot;.tokenize.get(1).syntax
res0: java.lang.Boolean = true</code></pre>
      The tokens are also structurally equal.

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foobar&quot;.tokenize.get(1).structure == &quot;foobar kas&quot;.tokenize.get(1).structure
res0: java.lang.Boolean = true</code></pre>
      However, they are not structurally equal if we move them around.

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;kas foobar&quot;.tokenize.get(3).structure == &quot;foobar kas&quot;.tokenize.get(1).structure
res0: java.lang.Boolean = false</code></pre>
    <h1 id=".get" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#.get" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>.get</h1>
      <p>
        Tokenization can sometimes fail, for example in this case:

        <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;&quot;&quot; val str = &quot;unclosed literal &quot;&quot;&quot;.tokenize.get
res0: scala.meta.tokenizers.TokenizeException = &lt;input&gt;:1: error: unclosed string literal
val str = &quot;unclosed literal
           ^</code></pre>
        <p>
          If you prefer, you can safely pattern match on the tokenize result

          <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;&quot;&quot; val str = &quot;closed literal&quot; &quot;&quot;&quot;.tokenize match {
  case Tokenized.Success(tokenized) =&gt; tokenized
  case Tokenized.Error(e) =&gt; ???
}
res0: scala.meta.tokens.Tokens =  val str = &quot;closed literal&quot; </code></pre></p></p></p>
  <h1 id="Exercises" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Exercises" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Exercises</h1>
    <p>
      Enough with explanations. Time to get your hands dirty.
</p>
    <h2 id="Checkifastringhasbalancednumberofcurlybraces" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Checkifastringhasbalancednumberofcurlybraces" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Check if a string has balanced number of curly braces</h2>
      <p>
        Implement the following method so that <code>BalancedSuite</code> passes.

        <pre><code class="scala scalatex-site-Styles-highlightMe">/** Replaces all var tokens with val tokens */
def isBalanced(tokens: Tokens): Boolean = ???
</code></pre></p>
    <h2 id="Stripawaytrailingcommas" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Stripawaytrailingcommas" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Strip away trailing commas</h2>
      <p>
        Implement the following method so that <code>TrailingCommaSuite</code> passes.

        <pre><code class="scala scalatex-site-Styles-highlightMe">/** Removes all commas behind the last argument of function calls */
def stripTrailingCommas(tokens: Tokens): String = ???
</code></pre></p>
      <div class="bs-callout bs-callout-info"><p>
        <b>NOTE</b>. You don't have access to an AST so you can't know for certain
        which parentheses belong to a function application. For this exercise,
        it's OK to just guess.
</p></div>
  <h1 id="Conclusion" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Conclusion" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Conclusion</h1>
    <p>
      Scala.meta tokens are the foundation of scala.meta.
      Sometimes you don't have access to a parsed AST and then your best shot is
      work with tokens, for example in the case of <a href="#Stripawaytrailingcommas">Strip away trailing commas</a>.
</p>
    <p>
      In the following chapter we will discuss another exciting data structure:
      the incredible <b>scala.meta.Tree</b>.</p>

  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Part2-Trees" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Part 2 - Trees<a class=" scalatex-site-Styles-headerLink" href="#Part2-Trees" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  <p>
    Reminder. We assume you have this import in scope:
</p>
  <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; import scala.meta._
res0: scala.runtime.BoxedUnit = ()</code></pre>
  <h1 id="q&quot;Quasiquotes&quot;" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#q&quot;Quasiquotes&quot;" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>q&quot;Quasiquotes&quot;</h1>
    <p>
      The easiest way to get started with scala.meta trees is using quasiquotes.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;case class User(name: String, age: Int)&quot;
res0: scala.meta.Defn$Class$DefnClassImpl = case class User(name: String, age: Int)</code></pre>
    <p>
      Quasiquotes can be composed
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; val method = q&quot;def `is a baby` = age &lt; 1&quot;
scala&gt; q&quot;&quot;&quot;
case class User(name: String, age: Int) {
  $method
}
&quot;&quot;&quot;
res0: scala.meta.Defn$Class$DefnClassImpl = case class User(name: String, age: Int) { def `is a baby` = age &lt; 1 }</code></pre>
    <p>
      Quasiquotes can also be used to deconstruct trees with pattern matching
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;def `is a baby` = age &lt; 1&quot; match {
  case q&quot;def $name = $body&quot; =&gt;
    s&quot;You ${name.syntax} if your ${body.syntax}&quot;
}
res0: java.lang.String = 
&quot;You `is a baby` if your age &lt; 1&quot;</code></pre>
    <div class="bs-callout bs-callout-warning"><p>
      <b>NOTE</b>. Quasiquotes currently ignore comments:

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;val x = 2 // assignment&quot;.syntax
res0: java.lang.String = 
&quot;val x = 2&quot;</code></pre>
      If you need comments, you can use <a href="#.parse[T]">.parse[T]</a>

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2 // assignment&quot;.parse[Stat].get.syntax
res0: java.lang.String = 
&quot;val x = 2 // assignment&quot;</code></pre></p></div>
  <h1 id=".parse[T]" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#.parse[T]" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>.parse[T]</h1>
    <p>
      If the contents that you want to parse are only known at runtime,
      you can't use quasiquotes.
      For example, this happens when you need to parse file contents.
</p>
    <p>
      Here's how to parse a compilation unit.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;object Main extends App { println(1) }&quot;.parse[Source].get
res0: scala.meta.Source$SourceImpl = object Main extends App { println(1) }</code></pre>
    <div class="bs-callout bs-callout-success"><p>
      Pro tip. You can also call <code>.parse[T]</code> on a <code>File</code>,
      just like this

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; new java.io.File(&quot;readme/ParseMe.scala&quot;).parse[Source]
res0: scala.meta.parsers.Parsed$Success = class ParseMe { println(&quot;I'm inside a file&quot;) }
</code></pre></p></div>
    <p>
      If we try to parse a statement as a compilation unit we will fail.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.parse[Source].get
res0: scala.meta.parsers.ParseException = &lt;input&gt;:1: error: expected class or object definition
val x = 2
^</code></pre>
    <p>
      We need to explicitly parse it as a statement (<code>Stat</code>).
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;val x = 2&quot;.parse[Stat].get
res0: scala.meta.Defn$Val$DefnValImpl = val x = 2</code></pre>
    <p>
      We can also parse case statement
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;case Foo(bar) if bar &gt; 2 =&gt; println(bar)&quot;.parse[Case].get
res0: scala.meta.Case$CaseImpl = case Foo(bar) if bar &gt; 2 =&gt; println(bar)</code></pre>
    <p>
      Scala.meta has dozens of parsers:
      <div class="text-center"><img style="width: 100%" src="img/parse.png" /><p></p></div>
      However, <code>.parse[Stat]</code> and <code>.parse[Source]</code> are
      usually all you need.
</p>
  <h1 id="dialects" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#dialects" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>dialects</h1>
    <p>
      I didn't tell the whole story when I said you need to pass in a type
      argument to parse statements.
      You also need to pass in a dialect!
      However, scala.meta will by default pick the <code>Scala211</code> dialect
      for you if you don't provide one explicitly.
</p>
    <p>
      With the SBT dialects, we can parse vals as top-level statements.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; dialects.Sbt0137(
  &quot;lazy val core = project.settings(commonSettings)&quot;
).parse[Source].get
res0: scala.meta.Source$SourceImpl = lazy val core = project.settings(commonSettings)</code></pre>
    <p>
      We can even parse multiple top level statements
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; dialects.Sbt0137(
  &quot;&quot;&quot;
  lazy val core = project.settings(commonSettings)

  lazy val extra = project.dependsOn(core)
  &quot;&quot;&quot;
).parse[Source].get
res0: scala.meta.Source$SourceImpl = 
  lazy val core = project.settings(commonSettings)

  lazy val extra = project.dependsOn(core)
  </code></pre>
    <p>
      For the remainder of the workshop, we will only work with the <code>Scala211</code>
      dialect.
</p>
  <h1 id="Tree.syntax" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tree.syntax" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tree.syntax</h1>
    <p>
      Just like with tokens, we can also run <code>.syntax</code> on trees.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foo(bar)&quot;.parse[Stat].get.syntax
res0: java.lang.String = 
&quot;foo(bar)&quot;</code></pre>
    However, scala.meta can also do this even if you manually construct the tree

    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; Term.Apply(
  Term.Name(&quot;foo&quot;),
  scala.collection.immutable.Seq(
    Term.Name(&quot;bar&quot;): Term.Arg
  )
).syntax
res0: java.lang.String = 
&quot;foo(bar)&quot;</code></pre>
    <p>
      We never gave scala.meta parentheses but still it figured out we needed
      them.
      Pretty cool huh.
</p>
  <h1 id="Tree.structure" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tree.structure" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tree.structure</h1>
    <p>
      Just like with tokens, we can also run <code>.structure</code> on trees.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foo(bar)&quot;.parse[Stat].get.structure
res0: java.lang.String = 
&quot;Term.Apply(Term.Name(\&quot;foo\&quot;), Seq(Term.Name(\&quot;bar\&quot;)))&quot;</code></pre>
    <p>
      <code>.structure</code> ignores any syntactic trivia like whitespace and comments
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; &quot;foo  ( /* this is a comment */ bar  ) // eol&quot;.parse[Stat].get.structure
res0: java.lang.String = 
&quot;Term.Apply(Term.Name(\&quot;foo\&quot;), Seq(Term.Name(\&quot;bar\&quot;)))&quot;</code></pre>
    <p>
      This can be useful for example in debugging, testing or equality checking.
</p>
  <h1 id="Tree.==" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tree.==" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tree.==</h1>
    <p>
      Just like with tokens, tree equality is by default by reference:
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;foo(bar)&quot; == q&quot;foo(bar)&quot;
res0: java.lang.Boolean = false</code></pre>
    This means you need to be explicit if you mean syntactic equality

    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;foo(bar)&quot;.syntax == q&quot;foo(bar)&quot;.syntax
res0: java.lang.Boolean = true</code></pre>
    <p>
      or structural equality
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;foo(bar)&quot;.structure == q&quot;foo(bar)&quot;.structure
res0: java.lang.Boolean = true</code></pre>
  <h1 id="Comprehensivetrees" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Comprehensivetrees" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Comprehensive trees</h1>
    <p>
      A key feature of scala.meta trees is that they comprehensively cover
      all corners of the Scala syntax.
      A side effect of this is that the scala.meta tree hierarchy contains a
      lot of types.
      For example, there is a different tree node for an abstract <code>def</code> (<code>Decl.Def</code>)

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;def add(a: Int, b: Int)&quot;
res0: scala.meta.Decl$Def$DeclDefImpl = def add(a: Int, b: Int): Unit</code></pre>
      and a <code>def</code> with an implementation (<code>Defn.Def</code>)

      <pre><code class="scala scalatex-site-Styles-highlightMe">scala&gt; q&quot;def add(a: Int, b: Int) = a + b&quot;
res0: scala.meta.Defn$Def$DefnDefImpl = def add(a: Int, b: Int) = a + b</code></pre>
      <p>
        Fortunately, most of the time you won't need to worry about this.
        Quasiquotes help you create/match/compose/deconstruct the correct instances.
        However, occasionally you may need to debug the types of the trees you have.
</p>
      <p>
        For your convenience, I've compiled together the most common types in
        this handy diagram:
        <div class="text-center"><img style="width: 100%" src="img/tree.png" /><p></p></div></p></p>
  

<h1 id="Exercises" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Exercises" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Exercises</h1>

  <h2 id="Don'tcatchThrowable" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Don'tcatchThrowable" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Don't catch Throwable</h2>
    <pre><code class="scala scalatex-site-Styles-highlightMe">// Refactor this
object A {
  try danger() {
    catch e: Throwable =&gt; // swallows stack overflow / out of memory errors
      body
  }
}

// into this
object A {
  try danger() {
    catch scala.util.control.NonFatal(e) =&gt;
      body
  }
}
</code></pre>
    For extra credit, you can:

    <ul>
      <li>
        Add an <code>import scala.util.control.NonFatal</code> at the top of the file,
        if the import doesn't already exist.</li>
      <li>
        Allow the user to disable the rewrite with a comment like this:
</li></ul>
    <pre><code class="scala scalatex-site-Styles-highlightMe">catch {
  case e: Throwable =&gt; // scalaworld: off
}
</code></pre>
  <h2 id="Rewritelst.filter(cond).headOptiontolst.find(cond)" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Rewritelst.filter(cond).headOptiontolst.find(cond)" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Rewrite lst.filter(cond).headOption to lst.find(cond)</h2>
    <p>
      Implement <code>noFilterHeadOption</code> so that <code>FilterHeadSuite</code> passes.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">/** Rewrites lst.filter(cond).headOption to lst.find(cond) */
def noFilterHeadOption(tree: Tree): Tree = ???
</code></pre>
  <h2 id="Removeredundantcallstosbtsettings" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Removeredundantcallstosbtsettings" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Remove redundant calls to sbt settings</h2>

    <pre><code class="scala scalatex-site-Styles-highlightMe">// Refactor this
project

  .settings(commonSettings: _*)
  .settings(publishSettings: _*)
  .settings(
    libraryDeps += &quot;&quot;
  )

// into this
project.settings(
  commonSettings,
  publishSettings,
  libraryDeps += &quot;&quot;
)
</code></pre>
  <h2 id="Neverdolst.length==0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Neverdolst.length==0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Never do lst.length == 0</h2>

    <pre><code class="scala scalatex-site-Styles-highlightMe">// Refactor this
lst.length == 0

// into this
lst.nonEmpty
</code></pre>
  <h2 id="AvoidFuture.applywhenpossible" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#AvoidFuture.applywhenpossible" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Avoid Future.apply when possible</h2>

    <pre><code class="scala scalatex-site-Styles-highlightMe">// Refactor this
Future(&lt;Some literal&gt;)
Future { &lt;Some literal&gt; }

// into this
Future.successful(&lt;Some literal&gt;)
Future.successful { &lt;Some literal&gt; }
</code></pre>
  <h2 id="PreferOption(x)toSome(x)" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#PreferOption(x)toSome(x)" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Prefer Option(x) to Some(x)</h2>
    <p>
      To prevent <code>Some(null)</code>.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">// Refactor this
Some(arg)

// into this
Option(arg)</code></pre>


  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Part3-Devtools" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Part 3 - Devtools<a class=" scalatex-site-Styles-headerLink" href="#Part3-Devtools" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  <p>
    Let's build a command line tool called <code>scalaworld</code>.
    The tool will run the <a href="#Don'tcatchThrowable">Don't catch Throwable</a> rewrite on
    scala source files.
</p>
  <h1 id="NonFatalRewrite" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#NonFatalRewrite" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>NonFatal Rewrite</h1>
    <p>
      To start with, open the file <code>NonFatal.scala</code> in the package
      <code>scalaworld.rewrite</code>.
      The file looks like this:
</p>
    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">package scalaworld.rewrite

import scala.meta._
import scalaworld.Fixed
import scalaworld.util.logger

/**
  * Rewrite this
  * {{{
  *   catch {
  *     case e: Throwable =&gt; ...
  *   }
  * }}}
  *
  * into this
  * {{{
  *   catch {
  *     case NonFatal(e) =&gt; ...
  *   }
  * }}}
  *
  */
object NonFatal extends Rewrite {
  override def rewrite(code: Input): Fixed =
    withParsed(code) { tree =&gt;
      val patches = tree.collect {
        case c @ p&quot;case $name: Throwable =&gt; $expr&quot; =&gt;
          val pat = c.asInstanceOf[Case].pat
          Patch(pat.tokens.head, pat.tokens.last, s&quot;NonFatal(${name.syntax})&quot;)
      }
      Fixed.Success(Patch.run(tree.tokens, patches))
    }
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/scalacenter/scalaworld/tree/master/core/src/main/scala/scalaworld/rewrite/NonFatal.scala#L0-L33" target="_blank"><i class="fa fa-link "></i></a></pre>

    <p>
      Plug in your implementation of the <a href="#Don'tcatchThrowable">Don't catch Throwable</a>
      exercise.
      Keep running <code>~core/testOnly scalaworld.rewrite.NonFatalTest</code>
      until the tests suite passes.

</p>
  <h1 id="BuildingCLI" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#BuildingCLI" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Building CLI</h1>
    <p>
      Let's run your NonFatal rewrite rule on some real-world Scala code.
</p>
    <p>
      Run the following commands to package and install the <code>scalaworld</code> CLI
      interface.
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">sbt cli/pack
cd cli/target/pack
make install // adds `scalaworld` to PATH
</code></pre>
    <p>
      Next, clone <a href="https://github.com/olafurpg/scala-repos">scala-repos</a>.
      The repository contains source files
      over 3 million lines of Scala source code from over 20 Scala open source
      projects.
</p>
    <p>
      Enter the <code>scala-repos</code> directory and execute
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scalaworld -i --rewrite NonFatal repos/kafka
</code></pre>
    <p>
      Everything ok? Try this now
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">scalaworld -i --rewrite NonFatal repos // Run on EVERYTHING</code></pre>

  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Part4-Macroannotations" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Part 4 - Macro annotations<a class=" scalatex-site-Styles-headerLink" href="#Part4-Macroannotations" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  <p>
    It's possible to write macro annotations on scala.meta trees using
    scala.meta paradise.
    From sbt, run your first macro annotation with
</p>
  <pre><code class="scala scalatex-site-Styles-highlightMe">macros/test:run
</code></pre>
  Here is an example macro annotation:

  <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">package scalaworld.macros

import scala.meta._

class Main extends scala.annotation.StaticAnnotation {
  inline def apply(defn: Any): Any = meta {
    defn match {
      case q&quot;object $name { ..$stats }&quot; =&gt;
        val main = q&quot;def main(args: Array[String]): Unit = { ..$stats }&quot;
        q&quot;object $name { $main }&quot;
      case _ =&gt;
        abort(&quot;@main must annotated on an object.&quot;)
    }
  }
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/scalacenter/scalaworld/tree/master/macros/src/main/scala/scalaworld/macros/Main.scala#L0-L16" target="_blank"><i class="fa fa-link "></i></a></pre>

  The annotation wraps the body of an object into a <code>main</code> function, serving
  a similar function as extending <code>App</code>.

  <h1 id="Class2Mapmacro" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Class2Mapmacro" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Class2Map macro</h1>
    Implement a <code>Class2Map</code> macro annotation that injects a <code>toMap</code> method
    that creates a <code>Map[String, Any]</code> from the fields of this class.

    <p>
      Here is the solution.
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">package scalaworld.macros

import scala.collection.immutable.Seq
import scala.meta._

class Class2Map extends scala.annotation.StaticAnnotation {
  inline def apply(defn: Any): Any = meta {
    defn match {
      case cls@ Defn.Class(_, _, _, Ctor.Primary(_, _, paramss), template) =&gt;
        val namesToValues: Seq[Term.Tuple] = paramss.flatten.map { param =&gt;
          q&quot;(${param.name.syntax}, ${Term.Name(param.name.value)})&quot;
        }
        val toMapImpl: Term = q&quot;_root_.scala.collection.Map(..$namesToValues)&quot;
        val toMap =
          q&quot;def toMap: _root_.scala.collection.Map[String, Any] = $toMapImpl&quot;
        val templateStats: Seq[Stat] = template.stats match {
          case Some(stats) =&gt; toMap +: stats
          case None =&gt; toMap :: Nil
        }
        cls.copy(templ = template.copy(stats = Some(templateStats)))
      case _ =&gt;
        println(defn.structure)
        abort(&quot;@Class2Map must be annotated on a class.&quot;)
    }
  }
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/scalacenter/scalaworld/tree/master/macros/src/main/scala/scalaworld/macros/Class2Map.scala#L0-L26" target="_blank"><i class="fa fa-link "></i></a></pre>
</p>
  <h1 id="WithApplymacro" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#WithApplymacro" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>WithApply macro</h1>
    Implement a <code>WithApply</code> macro annotation that creates a <code>apply</code>
    method to construct an instance of the class (just like is created for case classes).

    <p>
      The challenge here is to handle the companion object correctly.

      <ul>
        <li>
          If the companion object exists, add the <code>apply</code> method to it.</li>
        <li>
          If the companion object doesn't exists, create it.</li></ul></p>
    <p>
      Here is the solution.
      <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">package scalaworld.macros

import scala.collection.immutable.Seq
import scala.meta._

class WithApply extends scala.annotation.StaticAnnotation {
  inline def apply(defn: Any): Any = meta {
    def createApply(name: Type.Name, paramss: Seq[Seq[Term.Param]]): Defn.Def = {
      val args = paramss.map(_.map(param =&gt; Term.Name(param.name.value)))
      q&quot;&quot;&quot;def apply(...$paramss): $name =
            new ${Ctor.Ref.Name(name.value)}(...$args)&quot;&quot;&quot;
    }
    defn match {
      // companion object exists
      case Term.Block(
          Seq(cls @ Defn.Class(_, name, _, ctor, _),
              companion: Defn.Object)) =&gt;
        val applyMethod = createApply(name, ctor.paramss)
        val templateStats: Seq[Stat] = companion.templ.stats match {
          case Some(stats) =&gt; applyMethod +: stats
          case None =&gt; applyMethod :: Nil
        }
        val newCompanion = companion.copy(
          templ = companion.templ.copy(stats = Some(templateStats)))
        Term.Block(Seq(cls, newCompanion))
      // companion object does not exists
      case cls @ Defn.Class(_, name, _, ctor, _) =&gt;
        val applyMethod = createApply(name, ctor.paramss)
        val companion = q&quot;object ${Term.Name(name.value)} { $applyMethod }&quot;
        Term.Block(Seq(cls, companion))
      case _ =&gt;
        println(defn.structure)
        abort(&quot;@WithApply must be annotated on a class.&quot;)
    }
  }
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/scalacenter/scalaworld/tree/master/macros/src/main/scala/scalaworld/macros/WithApply.scala#L0-L36" target="_blank"><i class="fa fa-link "></i></a></pre>
</p>
  <h1 id="Debugmacro" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Debugmacro" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Debug macro</h1>
    Open up <code>Debug.scala</code> and implement a <code>Debug</code> macro annotation
    for <b>methods</b> that:

    <ul>
      <li>
        Prints out the argument names and their values at the beginning of the method.</li>
      <li>
        Prints out the time it took to run the method.</li>
      <li>
        Prints out the value of the method result.
</li></ul>
    For extra credit:
    <ul>
      <li>
        Expand the method into two methods, where one is the original method
        and the second one has a named suffixed with <code>Debug</code>
        and that's where the printing happens.
        The biggest challenge is to transform the argument list into a
        function call on the original method.
</li></ul>

  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="FAQ" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">FAQ<a class=" scalatex-site-Styles-headerLink" href="#FAQ" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
  Some common questions that have been raised on Gitter.

  <h1 id="HowdoIgetthetypeofatree?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#HowdoIgetthetypeofatree?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>How do I get the type of a tree?</h1>
    You can't do that with scala.meta 1.x.
    Semantic information (like inferred type, symbols, resolved names) is
    on the roadmap for scala.meta 2.x.

  <h1 id="WhatisthequasiquoteforX?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#WhatisthequasiquoteforX?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>What is the quasiquote for X?</h1>
    Here is an overview of quasiquote syntax: <a href="https://github.com/scalameta/scalameta/blob/master/notes/quasiquotes.md">https://github.com/scalameta/scalameta/blob/master/notes/quasiquotes.md</a>.

  <h1 id="HowdoIpassanargumenttothemacroannotation?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#HowdoIpassanargumenttothemacroannotation?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>How do I pass an argument to the macro annotation?</h1>
    You match on <code>this</code> as a scala.meta tree. For example:

    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">package scalaworld.macros

import scala.meta._

class Argument(arg: Int) extends scala.annotation.StaticAnnotation {
  inline def apply(defn: Any): Any = meta {
    // `this` is a scala.meta tree.
    println(this.structure)
    val arg = this match {
      // The argument needs to be a literal like `1` or a string like `&quot;foobar&quot;`.
      // You can't pass in a variable name.
      case q&quot;new $_(${Lit(arg: Int)})&quot; =&gt; arg
      // Example if you have more than one argument.
      case q&quot;new $_(${Lit(arg: Int)}, ${Lit(foo: String)})&quot; =&gt; arg
      case _ =&gt; ??? // default value
    }
    println(s&quot;Arg is $arg&quot;)
    defn.asInstanceOf[Stat]
  }
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/scalacenter/scalaworld/tree/master/macros/src/main/scala/scalaworld/macros/Argument.scala#L0-L20" target="_blank"><i class="fa fa-link "></i></a></pre>

  <h1 id="DoIneedtodependonscala.metaatruntime?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#DoIneedtodependonscala.metaatruntime?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Do I need to depend on scala.meta at runtime?</h1>
    No. But your project needs a dependency on scala.meta.
    If you only use scala.meta at compile time, you can mark the dependency as
    <code>% &quot;provided&quot;</code> to exclude it from your runtime application.

  <h1 id="HowdoIreusecodebetweenmacros?" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#HowdoIreusecodebetweenmacros?" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>How do I reuse code between macros?</h1>
    If you try to call a method inside you macro class you get a &quot;X not found&quot; error.

    <pre><code class="scala scalatex-site-Styles-highlightMe">class Argument(arg: Int) extends scala.annotation.StaticAnnotation {
  def helper(t: Any): Stat = ??? // utility method
  inline def apply(defn: Any): Any = meta {
    helper(defn) // ERROR: `helper` not found
    // Why? `this` is a scala.meta tree.
}
</code></pre>
    You can move the utility method to an external object.

    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">package scalaworld.macros

import scala.meta._

object MacroUtil {
  def helper(defn: Any): Stat = q&quot;class ReuseExample&quot;
}

class Reuse extends scala.annotation.StaticAnnotation {
  inline def apply(defn: Any): Any = meta {
    MacroUtil.helper(defn)
  }
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/scalacenter/scalaworld/tree/master/macros/src/main/scala/scalaworld/macros/MacroUtil.scala#L0-L13" target="_blank"><i class="fa fa-link "></i></a></pre>

  <h1 id="Incrementalcompilerismessingup" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Incrementalcompilerismessingup" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Incremental compiler is messing up</h1>
    <div class="bs-callout bs-callout-success"><p>
      Pro tip. While editing the macro, it can be handy to keep this command
      running in SBT
      <pre><code class="scala scalatex-site-Styles-highlightMe">~; macros/test:clean ; macros/test:run</code></pre>
      Incremental compilation caches the macro expansion you need to clean the
      test project on every run.
</p></div>
  <h1 id="MyIDE/IntelliJisshowingallredsquigglymarks." style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#MyIDE/IntelliJisshowingallredsquigglymarks." style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>My IDE/IntelliJ is showing all red squiggly marks.</h1>

    Your IDE might be all red like this
    <div class="text-center"><img style="width: 100%" src="img/inline.png" /><p></p></div>
    There are two possible workarounds:

    <ol>
      <li>
        (Recommended)
        Install the
        <a href="https://confluence.jetbrains.com/display/IDEADEV/IDEA+2016.3+EAP">2016.3 EAP</a>
        and install the Scala plugin from the meta channel:
        <a href="https://plugins.jetbrains.com/plugins/meta/1347">https://plugins.jetbrains.com/plugins/meta/1347</a>.
        Settings -&gt; Plugins -&gt; Browse Repositories -&gt; Manage Repositories -&gt; &quot;+&quot;</li>
      <li>
        (hack)
        Add <code>import autocomplete._</code> to your file and a semicolon after <code>inline</code>,
        like this
        <div class="text-center"><img style="width: 100%" src="img/inline2.png" /><p></p></div>
        Remember to remove the semicolon when you run your macro.
</li></ol>

  

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Resources" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Resources<a class=" scalatex-site-Styles-headerLink" href="#Resources" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>

  <ul>
    <li>
      scala.meta website: <a href="http://scalameta.org">http://scalameta.org</a></li>
    <li>
      Please report macro annotation bug issues to scala.meta paradise:
      <a href="https://github.com/scalameta/paradise/">https://github.com/scalameta/paradise/</a>.</li>
    <li>
      For more macro annotation examples, see
      <a href="https://github.com/DavidDudson/Elysium">Elysium</a>.</li></ul>

  


  <!-- Stats -->
  <script type="text/javascript">
    var _paq = _paq || [];
    _paq.push(["setDomains", ["*.olafurpg.github.io/scala.meta-workshop"]]);
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
      var u="https://stats.lassie.io/hello/";
      _paq.push(['setTrackerUrl', u+'hello.php']);
      _paq.push(['setSiteId', 5]);
      var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
      g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'hello.js'; s.parentNode.insertBefore(g,s);
    })();
  </script>
  <noscript><p><img src="https://stats.lassie.io/hello/hello.php?idsite=5" style="border:0;" alt="" /></p></noscript>
  <!-- End Stats Code -->
  <!-- Latest compiled and minified CSS -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <style>
    .bs-callout-danger {
      border-left-color: #ce4844 !IMPORTANT;
    }
    .bs-callout-danger h4 {
      color: #ce4844 !IMPORTANT;
    }
    .bs-callout-warning {
      border-left-color: #aa6708 !IMPORTANT;
    }
    .bs-callout-warning h4 {
      color: #aa6708 !IMPORTANT;
    }
    .bs-callout-info {
      border-left-color: #1b809e !IMPORTANT;
    }
    .bs-callout-info h4 {
      color: #1b809e !IMPORTANT;
    }
    .bs-callout-success {
      border-left-color: #5cb85c !IMPORTANT;
    }
    .bs-callout {
        padding: 20px;
        margin: 20px 0;
        border: 1px solid #eee;
        border-left-width: 5px;
        border-radius: 3px;
    }
    .scalatex-site-Styles-headerTag {
      margin-bottom: 20px !important;
    }
  </style>

</div>
</div><script>
    scalatex.scrollspy.Controller().main(
      [{"value":"A Whirlwind Tour of scala.meta","children":[{"value":"Abstract","children":[]},{"value":"Video","children":[]},{"value":"Part 0: Getting started","children":[]},{"value":"Part 1 - Tokens","children":[{"value":"Tokens.syntax","children":[]},{"value":"Tokens.structure","children":[]},{"value":"Tokens vs. Token","children":[]},{"value":"==","children":[]},{"value":".get","children":[]},{"value":"Exercises","children":[{"value":"Check if a string has balanced number of curly braces","children":[]},{"value":"Strip away trailing commas","children":[]}]},{"value":"Conclusion","children":[]}]},{"value":"Part 2 - Trees","children":[{"value":"q\"Quasiquotes\"","children":[]},{"value":".parse[T]","children":[]},{"value":"dialects","children":[]},{"value":"Tree.syntax","children":[]},{"value":"Tree.structure","children":[]},{"value":"Tree.==","children":[]},{"value":"Comprehensive trees","children":[]},{"value":"Exercises","children":[{"value":"Don't catch Throwable","children":[]},{"value":"Rewrite lst.filter(cond).headOption to lst.find(cond)","children":[]},{"value":"Remove redundant calls to sbt settings","children":[]},{"value":"Never do lst.length == 0","children":[]},{"value":"Avoid Future.apply when possible","children":[]},{"value":"Prefer Option(x) to Some(x)","children":[]}]}]},{"value":"Part 3 - Devtools","children":[{"value":"NonFatal Rewrite","children":[]},{"value":"Building CLI","children":[]}]},{"value":"Part 4 - Macro annotations","children":[{"value":"Class2Map macro","children":[]},{"value":"WithApply macro","children":[]},{"value":"Debug macro","children":[]}]},{"value":"FAQ","children":[{"value":"How do I get the type of a tree?","children":[]},{"value":"What is the quasiquote for X?","children":[]},{"value":"How do I pass an argument to the macro annotation?","children":[]},{"value":"Do I need to depend on scala.meta at runtime?","children":[]},{"value":"How do I reuse code between macros?","children":[]},{"value":"Incremental compiler is messing up","children":[]},{"value":"My IDE/IntelliJ is showing all red squiggly marks.","children":[]}]},{"value":"Resources","children":[]}]}]
  )</script><script>
    ['DOMContentLoaded', 'load'].forEach(function(ev){
      addEventListener(ev, function(){
        Array.prototype.forEach.call(
          document.getElementsByClassName('scalatex-site-Styles-highlightMe'),
          hljs.highlightBlock
        );
      })
    })
  </script></body></html>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         